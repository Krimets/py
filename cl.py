# Задача реализована в классе Poisk, с использованием рекурсии, словарей и списков.

class Poisk:  # создаём класс для работы с подобными задачами
    def __init__(self):  # инициализируем конструктор
        self.s = {}  # создаём пустой словарь
        self.d = []  # создаём пустой список

    def number(self, n=0):  # метод экземпляра класса для забора количества передаваемых значений
        self.n = n          # и формирования словаря
        for i in range(self.n):
            ll = input().split(' : ')  # разделяем данные на родителя и детей
            if len(ll) == 1:  # если значение только 1, значит это начальный объект
                self.s[ll[0]] = 'finish'  # тут будет заканчиваться поиск
            else:
                self.s[ll[0]] = ll[1]  # иначе формируем словарь

    def ask(self, z=0):  # метод получает количество запросов
        self.z = z
        self.search()  # запускает метод поиска

    def sup(self, po, v):  # рекурсивный поиск
        v = v.split(' ')  # разделяем детей
        for i in v:  # для каждого ребёнка создаём поиск
            if i != '' and i in self.s:  # если не равен '' и есть в родителях словаря
                if po in self.s.get(i):  # ищем родителя у детей
                    k = 'Yes'  # если найден
                    self.odin(k)  # передаём в odin значение 'Yes'
                else:
                    k = 'No'  # если не найден
                    self.odin(k)  # передаём в odin значение 'No'
                    self.sup(po, self.s.get(i))  # и запускаем метод заново, с новыми значениями детей

    def odin(self, k):  # Собирает значения 'Yes' и 'No'
        self.k = k
        self.d.append(k)  # Собирает значения в список
        return self.d  # отдаёт список

    def search(self):  # метод поиска и проверки
        for i in range(self.z):  # количество повторений запроса
            pp = input().split(' ')  # разделяем запрос на родителя и детей
            if pp[1] == pp[0]:  # если родитель == ребёнку
                print('Yes')  # значит он является предком
            else:
                if pp[1] in self.s:  # если родитель в словаре
                    if pp[0] in self.s.get(pp[1]):  # если ребёнок найден у этого родителя
                        print('Yes')  # значит родитель является предком
                        self.d = []  # обнуляем список метода odin
                    else:
                        if 'Yes' in self.odin(self.sup(pp[0], self.s.get(pp[1]))):  # иначе запускаем метод sup,
                                                                                    # проверяем есть ли в списке 'Yes'
                            print('Yes')  # если метод нашёл совпадения, значит родитель является предком
                            self.d = []  # обнуляем список метода odin
                        else:
                            print('No')
                            self.d = []  # обнуляем список метода odin
                else:  # если родителя нет в словаре
                    print('No')
                    self.d = []  # обнуляем список метода odin
x = Poisk()  # создаём объект класса
x.number(int(input()))  # передаём значения
x.ask(int(input()))  # передаём значения
